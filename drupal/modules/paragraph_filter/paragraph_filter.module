<?php
// $Id$

/**
 * Implements hook_filter_info().
 */
function paragraph_filter_filter_info() {
  $filters['linebreak'] = array(
    'title' => t('Convert line breaks into HTML (i.e. <code>&lt;br&gt;</code> and <code>&lt;p&gt;</code>) (XHTML-compliant)'),
    'process callback' => 'paragraph_filter_process',
    'tips callback' => 'paragraph_filter_tips',
  );

  return $filters;
}



/**
 * Filter tips callback for auto-paragraph filter.
 */
function paragraph_filter_tips($filter, $format, $long = FALSE) {
  if ($long) {
    return t('Lines and paragraphs are automatically recognized. The &lt;br /&gt; line break, &lt;p&gt; paragraph and &lt;/p&gt; close paragraph tags are inserted automatically. If paragraphs are not recognized simply add a couple blank lines.');
  }
  else {
    return t('Lines and paragraphs break automatically.');
  }
}

/**
 * Converts line breaks in text into <p> and <br /> in an intelligent fashion,
 * preserving existing HTML tags.
 *
 * @param $text
 *   String of text to process.
 *
 * @return
 *   Processed text with paragraph tags inserted.
 */
function _paragraph_filter_process($text) {
  $blocklevel = 'body|table|thead|tfoot|caption|col|colgroup|tbody|tr|td|th|div|p|dl|dd|dt|ul|ol|li|pre|select|option|form|map|area|blockquote|address|math|style|p|h[1-6]|hr|fieldset|legend|section|article|aside|hgroup|header|footer|nav|figure|figcaption|details|menu|summary';
  $parse_state = &drupal_static(__FUNCTION__, array('p_open' => FALSE, 'tag_stack' => array()));

  // Split at opening and closing PRE, SCRIPT, STYLE, OBJECT tags and comments.
  // We don't apply any processing to the contents of these tags to avoid messing
  // up code. We look for matched pairs and allow basic nesting. For example:
  // "processed <pre> ignored <script> ignored </script> ignored </pre> processed"
  $chunks = preg_split('@(<!--.*?-->|</?(?:pre|script|style|object|!--)[^>]*>)@i', $text, -1, PREG_SPLIT_DELIM_CAPTURE);
  // Note: PHP ensures the array consists of alternating delimiters and literals
  // and begins and ends with a literal (inserting NULL as required).
  $ignore = FALSE;
  $ignoretag = '';
  $output = '';
  foreach ($chunks as $i => $chunk) {
    if ($i % 2) {
      // Opening or closing tag?
      $open = ($chunk[1] != '/' || $chunk[1] != '!');
      $comment = (substr($chunk, 0, 4) == '<!--');
      list($tag) = preg_split('/[ >]/', substr($chunk, 2 - $open), 2);
      if (!$ignore) {
        if ($open) {
          $ignore = TRUE;
          $ignoretag = $tag;
        }
      }
      // Only allow a matching tag to close it.
      elseif ((!$open && $ignoretag == $tag) || $comment) {
        $ignore = FALSE;
        $ignoretag = '';
      }
    }
    elseif (!$ignore) {
      // Normalize line endings.
      $chunk = str_replace(array("\r\n", "\r"), "\n", $chunk);
      // Convert double break tags to double newlines, so they can be
      // interpreted as paragraphs later.
      $chunk = preg_replace('~<br />\s*<br />~', "\n\n", $chunk);
      // Add line breaks inside divs, so paragraphs can start immediately
      // after a <div> tag.
      $chunk = preg_replace("~(<div[^>]*>)([^\s])~", "$1\n$2", $chunk);
      $chunk = preg_replace("~([^\s])(</div[^>]*>)~", "$1\n$2", $chunk);
      // Send chunks deliminated by whitespace to our callback.
      $chunk = preg_replace_callback('~.+($|\s+)~', 'paragraph_filter_callback', $chunk);
      if ($parse_state['p_open']) {
        // Close the dangling paragraph tag.
        $chunk = preg_replace('~(\s*)$~', '</p>$1', $chunk, 1);
      }
      // Remove trailing whitespace from inside paragrahs.
      $chunk = preg_replace('~(\s+)</p>~', '</p>$1', $chunk);
      // Convert single newlines to <br />.
      $chunk = preg_replace("~([^\n])\n([^\n])~", "$1<br />\n$2", $chunk);
      $chunk = preg_replace("~<br />\n(\s*</?(?:" . $blocklevel . "|legend)[^>]*>)~", "\n$1", $chunk);
      $chunk = preg_replace("~(</?(?:" . $blocklevel . "|legend)[^>]*>\s*)<br />\n~", "$1\n", $chunk);
    }
    $output .= $chunk;
  }

  // Clean up $parse_state for subsequent runs.
  drupal_static_reset(__FUNCTION__);

  return $output;
}

/**
 * Regex replacement callback used internally by paragraph_filter_process().
 *
 * @param $matches
 *   Array of matches, passed by preg_replace_callback().
 *
 * @return
 *   The replacement string.
 */
function paragraph_filter_callback($matches) {
  $blocklevel = 'body|table|thead|tfoot|caption|col|colgroup|tbody|tr|td|th|div|p|dl|dd|dt|ul|ol|li|pre|select|option|form|map|area|blockquote|address|math|style|p|h[1-6]|hr|fieldset|legend|section|article|aside|hgroup|header|footer|nav|figure|figcaption|details|menu|summary';
  $inline = 'a|abbr|acronym|b|basefont|bdo|big|br|cite|code|dfn|em|font|i|img|input|kbd|label|q|s|samp|select|small|span|strike|del|strong|sub|sup|textarea|tt|u|var';
  $text = $matches[0];
  $parse_state = &drupal_static('_paragraph_filter_process');

  // Keep a persistent tag stack so we can determine what tags we're inside of
  // from previous passes.
  preg_match_all('~<(/)?(\w+)( [^/>]*?)?>~', $text, $tag_matches);
  if ($tag_matches[2]) {
    foreach ($tag_matches[2] as $i => $tag) {
      $is_close = (bool) $tag_matches[1][$i];
      if ($is_close && $tag == end($parse_state['tag_stack'])) {
        array_pop($parse_state['tag_stack']);
      }
      elseif (!$is_close) {
        array_push($parse_state['tag_stack'], $tag);
      }
    }
  }

  // If no <p> is started and no block level element is imminent, start one.
  if (!$parse_state['p_open'] && !preg_match('~^</?(' . $blocklevel . ')[^>]*>~', $text)) {
    $text = '<p>' . $text;
    $parse_state['p_open'] = TRUE;
  }
  // If a <p> is started and a block level element is being closed, close <p>.
  if ($parse_state['p_open'] && preg_match('~</(' . $blocklevel . ')[^>]*>~', $text)) {
    $text = preg_replace('~(\s*)?(</(' . $blocklevel . ')[^>]*>)~', '$1</p>$2', $text, 1);
    $parse_state['p_open'] = FALSE;
  }
  // If <p> is started and we have double line breaks, convert to </p><p>.
  if ($parse_state['p_open'] && preg_match("~\n\s*\n+~", $text)) {
    // If we're inside an inline tag, we need to use <br /><br /> instead.
    if (array_intersect($parse_state['tag_stack'], explode('|', $inline))) {
      $text = preg_replace("~\n(\s*\n+\s*)~", "<br /><br />\n$1", $text);
    }
    else {
      $text = preg_replace("~\n(\s*\n+\s*)~", "</p>\n$1", $text);
      $parse_state['p_open'] = FALSE;
    }
  }

  return $text;
}
