Index: modules/filter/filter.module
===================================================================
RCS file: /cvs/drupal/drupal/modules/filter/filter.module,v
retrieving revision 1.332
diff -u -p -r1.332 filter.module
--- modules/filter/filter.module	26 May 2010 10:54:30 -0000	1.332
+++ modules/filter/filter.module	26 May 2010 23:26:20 -0000
@@ -1359,12 +1359,19 @@ function _filter_htmlcorrector($text) {
 }
 
 /**
- * Convert line breaks into <p> and <br> in an intelligent fashion.
- * Based on: http://photomatt.net/scripts/autop
+ * Converts line breaks in text into <p> and <br /> in an intelligent fashion,
+ * preserving existing HTML tags.
+ *
+ * @param $text
+ *   String of text to process.
+ *
+ * @return
+ *   Processed text with paragraph tags inserted.
  */
 function _filter_autop($text) {
-  // All block level tags
-  $block = '(?:table|thead|tfoot|caption|colgroup|tbody|tr|td|th|div|dl|dd|dt|ul|ol|li|pre|select|form|blockquote|address|p|h[1-6]|hr)';
+  $output = '';
+  $blocklevel = 'body|table|thead|tfoot|caption|col|colgroup|tbody|tr|td|th|div|p|dl|dd|dt|ul|ol|li|pre|select|option|form|map|area|blockquote|address|math|style|p|h[1-6]|hr|fieldset|legend|section|article|aside|hgroup|header|footer|nav|figure|figcaption|details|menu|summary';
+  $parse_state = &drupal_static('_filter_autop', array('p_open' => FALSE, 'tag_stack' => array()));
 
   // Split at <pre>, <script>, <style> and </pre>, </script>, </style> tags.
   // We don't apply any processing to the contents of these tags to avoid messing
@@ -1375,7 +1382,6 @@ function _filter_autop($text) {
   // and begins and ends with a literal (inserting NULL as required).
   $ignore = FALSE;
   $ignoretag = '';
-  $output = '';
   foreach ($chunks as $i => $chunk) {
     if ($i % 2) {
       // Opening or closing tag?
@@ -1394,30 +1400,93 @@ function _filter_autop($text) {
       }
     }
     elseif (!$ignore) {
-      $chunk = preg_replace('|\n*$|', '', $chunk) . "\n\n"; // just to make things a little easier, pad the end
-      $chunk = preg_replace('|<br />\s*<br />|', "\n\n", $chunk);
-      $chunk = preg_replace('!(<' . $block . '[^>]*>)!', "\n$1", $chunk); // Space things out a little
-      $chunk = preg_replace('!(</' . $block . '>)!', "$1\n\n", $chunk); // Space things out a little
-      $chunk = preg_replace("/\n\n+/", "\n\n", $chunk); // take care of duplicates
-      $chunk = preg_replace('/^\n|\n\s*\n$/', '', $chunk);
-      $chunk = '<p>' . preg_replace('/\n\s*\n\n?(.)/', "</p>\n<p>$1", $chunk) . "</p>\n"; // make paragraphs, including one at the end
-      $chunk = preg_replace("|<p>(<li.+?)</p>|", "$1", $chunk); // problem with nested lists
-      $chunk = preg_replace('|<p><blockquote([^>]*)>|i', "<blockquote$1><p>", $chunk);
-      $chunk = str_replace('</blockquote></p>', '</p></blockquote>', $chunk);
-      $chunk = preg_replace('|<p>\s*</p>\n?|', '', $chunk); // under certain strange conditions it could create a P of entirely whitespace
-      $chunk = preg_replace('!<p>\s*(</?' . $block . '[^>]*>)!', "$1", $chunk);
-      $chunk = preg_replace('!(</?' . $block . '[^>]*>)\s*</p>!', "$1", $chunk);
-      $chunk = preg_replace('|(?<!<br />)\s*\n|', "<br />\n", $chunk); // make line breaks
-      $chunk = preg_replace('!(</?' . $block . '[^>]*>)\s*<br />!', "$1", $chunk);
-      $chunk = preg_replace('!<br />(\s*</?(?:p|li|div|th|pre|td|ul|ol)>)!', '$1', $chunk);
-      $chunk = preg_replace('/&([^#])(?![A-Za-z0-9]{1,8};)/', '&amp;$1', $chunk);
+      // Normalize line endings.
+      $chunk = str_replace(array("\r\n", "\r"), "\n", $chunk);
+      // Convert double break tags to double newlines, so they can be
+      // interpreted as paragraphs later.
+      $chunk = preg_replace('~<br />\s*<br />~', "\n\n", $chunk);
+      // Add line breaks inside divs, so paragraphs can start immediately
+      // after a <div> tag.
+      $chunk = preg_replace("~(<div[^>]*>)([^\s])~", "$1\n$2", $chunk);
+      $chunk = preg_replace("~([^\s])(</div[^>]*>)~", "$1\n$2", $chunk);
+      // Send chunks deliminated by whitespace to our callback.
+      $chunk = preg_replace_callback('~.+($|\s+)~', '_filter_autop_callback', $chunk);
+      if ($parse_state['p_open']) {
+        // Close the dangling paragraph tag.
+        $chunk = preg_replace('~(\s*)$~', '</p>$1', $chunk, 1);
+      }
+      // Remove trailing whitespace from inside paragrahs.
+      $chunk = preg_replace('~(\s+)</p>~', '</p>$1', $chunk);
+      // Convert single newlines to <br />.
+      $chunk = preg_replace("~([^\n])\n([^\n])~", "$1<br />\n$2", $chunk);
+      $chunk = preg_replace("~<br />\n(\s*</?(?:" . $blocklevel . "|legend)[^>]*>)~", "\n$1", $chunk);
+      $chunk = preg_replace("~(</?(?:" . $blocklevel . "|legend)[^>]*>\s*)<br />\n~", "$1\n", $chunk);
     }
     $output .= $chunk;
   }
+
+  // Clean up $parse_state for subsequent runs.
+  drupal_static_reset('_filter_autop');
+
   return $output;
 }
 
 /**
+ * Regex replacement callback used internally by _filter_autop().
+ *
+ * @param $matches
+ *   Array of matches, passed by preg_replace_callback().
+ *
+ * @return
+ *   The replacement string.
+ */
+function _filter_autop_callback($matches) {
+  $blocklevel = 'body|table|thead|tfoot|caption|col|colgroup|tbody|tr|td|th|div|p|dl|dd|dt|ul|ol|li|pre|select|option|form|map|area|blockquote|address|math|style|p|h[1-6]|hr|fieldset|legend|section|article|aside|hgroup|header|footer|nav|figure|figcaption|details|menu|summary';
+  $inline = 'a|abbr|acronym|b|basefont|bdo|big|br|cite|code|dfn|em|font|i|img|input|kbd|label|q|s|samp|select|small|span|strike|strong|sub|sup|textarea|tt|u|var';
+  $text = $matches[0];
+  $parse_state = &drupal_static('_filter_autop');
+
+  // Keep a persistent tag stack so we can determine what tags we're inside of
+  // from previous passes.
+  preg_match_all('~<(/)?(\w+)( [^/>]*?)?>~', $text, $tag_matches);
+  if ($tag_matches[2]) {
+    foreach ($tag_matches[2] as $i => $tag) {
+      $is_close = (bool) $tag_matches[1][$i];
+      if ($is_close && $tag == end($parse_state['tag_stack'])) {
+        array_pop($parse_state['tag_stack']);
+      }
+      elseif (!$is_close) {
+        array_push($parse_state['tag_stack'], $tag);
+      }
+    }
+  }
+
+  // If no <p> is started and no block level element is imminent, start one.
+  if (!$parse_state['p_open'] && !preg_match('~^</?(' . $blocklevel . ')[^>]*>~', $text)) {
+    $text = '<p>' . $text;
+    $parse_state['p_open'] = TRUE;
+  }
+  // If a <p> is started and a block level element is being closed, close <p>.
+  if ($parse_state['p_open'] && preg_match('~</(' . $blocklevel . ')[^>]*>~', $text)) {
+    $text = preg_replace('~(\s*)?(</(' . $blocklevel . ')[^>]*>)~', '$1</p>$2', $text, 1);
+    $parse_state['p_open'] = FALSE;
+  }
+  // If <p> is started and we have double line breaks, convert to </p><p>.
+  if ($parse_state['p_open'] && preg_match("~\n\s*\n+~", $text)) {
+    // If we're inside an inline tag, we need to use <br /><br /> instead.
+    if (array_intersect($parse_state['tag_stack'], explode('|', $inline))) {
+      $text = preg_replace("~\n(\s*\n+\s*)~", "<br /><br />\n$1", $text);
+    }
+    else {
+      $text = preg_replace("~\n(\s*\n+\s*)~", "</p>\n$1", $text);
+      $parse_state['p_open'] = FALSE;
+    }
+  }
+
+  return $text;
+}
+
+/**
  * Filter tips callback for auto-paragraph filter.
  */
 function _filter_autop_tips($filter, $format, $long = FALSE) {
Index: modules/filter/filter.test
===================================================================
RCS file: /cvs/drupal/drupal/modules/filter/filter.test,v
retrieving revision 1.67
diff -u -p -r1.67 filter.test
--- modules/filter/filter.test	26 May 2010 10:54:30 -0000	1.67
+++ modules/filter/filter.test	26 May 2010 23:26:20 -0000
@@ -662,20 +662,78 @@ class FilterUnitTestCase extends DrupalU
 
     // Text within some contexts should not be processed.
     $f = _filter_autop("<script>aaa\nbbb\n\nccc</script>");
-    $this->assertEqual($f, "<script>aaa\nbbb\n\nccc</script>", t('Line breaking -- do not break scripts.'));
+
+    $this->assertEqual($f, "<script>aaa\nbbb\n\nccc</script>", t('Line break filter does not break script tags.'));
 
     $f = _filter_autop('<p><div>  </div></p>');
-    $this->assertEqual(substr_count($f, '<p>'), substr_count($f, '</p>'), t('Make sure line breaking produces matching paragraph tags.'));
+    $this->assertTagOrder($f, array('<p>', '<div>', '</div>', '</p>'), t('Line break filter does not alter existing paragraph tags.'));
 
     $f = _filter_autop('<div><p>  </p></div>');
-    $this->assertEqual(substr_count($f, '<p>'), substr_count($f, '</p>'), t('Make sure line breaking produces matching paragraph tags.'));
+    $this->assertTagOrder($f, array('<div>', '<p>', '</p>', '</div>'), t('Line break filter does not alter existing paragraph tags nested in divs.'));
 
-    $f = _filter_autop('<blockquote><pre>aaa</pre></blockquote>');
-    $this->assertEqual(substr_count($f, '<p>'), substr_count($f, '</p>'), t('Make sure line breaking produces matching paragraph tags.'));
+    $f = _filter_autop("<blockquote><pre>aaa\n\naaa</pre></blockquote>");
+    $this->assertTagOrder($f, array('<blockquote>', '<pre>', '</pre>', '</blockquote>'), t('Line break filter does not insert paragraphs in block level tags and avoids break pre tags.'));
 
     $limit = max(ini_get('pcre.backtrack_limit'), ini_get('pcre.recursion_limit'));
     $f = _filter_autop($this->randomName($limit));
     $this->assertNotEqual($f, '', t('Make sure line breaking can process long strings.'));
+
+    $text = <<<EOT
+<form action="http://example.com/">
+  <fieldset class="collapsible collapsed">
+    <legend>This is the legend</legend>
+
+    <div class="collapse-text">
+      <p>Paragraph text</p>
+    </div>
+  </fieldset>
+</form>
+EOT;
+    $f = _filter_autop($text);
+    $this->assertEqual($f, $text, t('Line break filter leaves typical form markup intact.'));
+
+    $text = <<<EOT
+<form action="http://example.com/"><fieldset class="collapsible collapsed">
+
+<legend>This is the legend</legend>    <div class="collapse-text">
+
+      Paragraph text  </div>  </fieldset>
+
+
+</form>
+EOT;
+    $f = _filter_autop($text);
+    $expected_tags = array('<form>', '<fieldset>', '<legend>', '</legend>', '<div>', '<p>', '</p>', '</div>', '</fieldset>', '</form>');
+    $this->assertTagOrder($f, $expected_tags, t('Line break filter leaves wildly spaced code intact.'));
+
+    $f = _filter_autop("<strong>Line 1 \n Line2\n\n Line3</strong>");
+    $expected_tags = array('<p>', '<strong>', '<br />', '<br />', '<br />', '</strong>', '</p>');
+    $this->assertTagOrder($f, $expected_tags, t('Line break filter does not end paragraphs inside inline tags.'));
+
+    $text = <<<EOT
+<img src="/logo.png" />
+
+<pre class="fun">
+Preformatted text
+  Indented
+</pre>
+
+<big class="fat">The quick brown fox <em>jumps over the lazy dog.
+
+The lazy dog</em> jumps over the quick brown </big>fox.
+
+<div id="some-id">
+  Quick lazy fox,
+
+  Jumps over a lazy fish.
+</div>
+The end.
+EOT;
+    $f = _filter_autop($text);
+    $expected_tags = array('<p>', '<img />', '</p>', '<pre>', '</pre>', '<p>',
+    '<big>', '<em>', '<br />', '<br />', '</em>', '</big>', '</p>', '<div>',
+    '<p>', '</p>', '<p>', '</p>', '</div>', '<p>', '</p>');
+    $this->assertTagOrder($f, $expected_tags, t('Line break filter properly handles complex code.'));
   }
 
   /**
@@ -1248,6 +1306,33 @@ alert("test")
     $f = @$function("\xc2\"");
     $this->assertEqual($f, '', t('The @function() function correctly filters invalid UTF-8.', $replacements));
   }
+
+  /**
+   * Helper method to test that an HTML string consists of tags in the
+   * given order. The function ignores tag attributes and whitespace
+   * between tags.
+   *
+   * @param $html
+   *   String of HTML to test.
+   * @param $tags
+   *   Numeric array of tags. Example: <p>, <strong>, <br />, </strong>, </p>.
+   * @param $message
+   *   Optional message for assertion log.
+   *
+   * @return
+   *   TRUE on pass, FALSE on fail.
+   */
+  function assertTagOrder($html, $tags, $message = NULL) {
+    $matches = array();
+    $matched_tags = array();
+    preg_match_all('~<(/?)([\w]+)(?:[^>]*?)?( /)?>~', $html, $matches);
+    if (count($matches[0])) {
+      foreach ($matches[0] as $i => $match) {
+        $matched_tags[] = '<' . $matches[1][$i] . $matches[2][$i] . $matches[3][$i] . '>';
+      }
+    }
+    return $this->assertEqual($tags, $matched_tags, $message ? $message : t('Tag order is correct.'));
+  }
 }
 
 /**
