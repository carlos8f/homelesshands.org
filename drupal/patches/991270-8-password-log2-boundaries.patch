Index: includes/password.inc
===================================================================
RCS file: /cvs/drupal/drupal/includes/password.inc,v
retrieving revision 1.8
diff -u -p -r1.8 password.inc
--- includes/password.inc	4 May 2010 15:47:03 -0000	1.8
+++ includes/password.inc	8 Dec 2010 04:57:30 -0000
@@ -99,12 +99,17 @@ function _password_base64_encode($input,
  */
 function _password_generate_salt($count_log2) {
   $output = '$S$';
-  // Minimum log2 iterations is DRUPAL_MIN_HASH_COUNT.
-  $count_log2 = max($count_log2, DRUPAL_MIN_HASH_COUNT);
-  // Maximum log2 iterations is DRUPAL_MAX_HASH_COUNT.
+  // Ensure that $count_log2 is within set bounds.
+  if ($count_log2 < DRUPAL_MIN_HASH_COUNT) {
+    $count_log2 = DRUPAL_MIN_HASH_COUNT;
+  }
+  elseif ($count_log2 > DRUPAL_MAX_HASH_COUNT) {
+    $count_log2 = DRUPAL_MAX_HASH_COUNT;
+  }
+
   // We encode the final log2 iteration count in base 64.
   $itoa64 = _password_itoa64();
-  $output .= $itoa64[min($count_log2, DRUPAL_MAX_HASH_COUNT)];
+  $output .= $itoa64[$count_log2];
   // 6 bytes is the standard salt for a portable phpass hash.
   $output .= _password_base64_encode(drupal_random_bytes(6), 6);
   return $output;
@@ -261,7 +266,15 @@ function user_needs_new_hash($account) {
   if ((substr($account->pass, 0, 3) != '$S$') || (strlen($account->pass) != DRUPAL_HASH_LENGTH)) {
     return TRUE;
   }
+  $count_log2 = (int) variable_get('password_count_log2', DRUPAL_HASH_COUNT);
+  // Ensure that $count_log2 is within set bounds.
+  if ($count_log2 < DRUPAL_MIN_HASH_COUNT) {
+    $count_log2 = DRUPAL_MIN_HASH_COUNT;
+  }
+  elseif ($count_log2 > DRUPAL_MAX_HASH_COUNT) {
+    $count_log2 = DRUPAL_MAX_HASH_COUNT;
+  }
   // Check whether the iteration count used differs from the standard number.
-  return (_password_get_count_log2($account->pass) != variable_get('password_count_log2', DRUPAL_HASH_COUNT));
+  return (_password_get_count_log2($account->pass) !== $count_log2);
 }
 
Index: modules/simpletest/simpletest.info
===================================================================
RCS file: /cvs/drupal/drupal/modules/simpletest/simpletest.info,v
retrieving revision 1.26
diff -u -p -r1.26 simpletest.info
--- modules/simpletest/simpletest.info	22 Oct 2010 16:36:14 -0000	1.26
+++ modules/simpletest/simpletest.info	8 Dec 2010 04:57:30 -0000
@@ -31,6 +31,7 @@ files[] = tests/lock.test
 files[] = tests/mail.test
 files[] = tests/menu.test
 files[] = tests/module.test
+files[] = tests/password.test
 files[] = tests/path.test
 files[] = tests/registry.test
 files[] = tests/schema.test
Index: modules/simpletest/tests/password.test
===================================================================
RCS file: modules/simpletest/tests/password.test
diff -N modules/simpletest/tests/password.test
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ modules/simpletest/tests/password.test	8 Dec 2010 04:57:30 -0000
@@ -0,0 +1,59 @@
+<?php
+// $Id$
+
+/**
+ * @file
+ * Provides unit tests for password.inc.
+ */
+
+/**
+ * Unit tests for password hashing API.
+ */
+class PasswordHashingTest extends DrupalWebTestCase {
+  protected $profile = 'testing';
+
+  public static function getInfo() {
+    return array(
+      'name' => 'Password hashing',
+      'description' => 'Password hashing unit tests.',
+      'group' => 'System',
+    );
+  }
+
+  function setUp() {
+    require_once DRUPAL_ROOT . '/includes/password.inc';
+    parent::setUp();
+  }
+
+  /**
+   * Test password hashing.
+   */
+  function testPasswordHashing() {
+    // Set a log2 iteration count that is deliberately out of bounds to test
+    // that it is corrected to be within bounds.
+    variable_set('password_count_log2', 4);
+    // Set up a fake $account with a password 'baz', hashed with md5.
+    $password = 'baz';
+    $account = (object) array('name' => 'foo', 'pass' => md5($password));
+    // The md5 password should be flagged as needing an update.
+    $this->assertTrue(user_needs_new_hash($account), t('User with md5 password needs a new hash.'));
+    // Re-hash the password.
+    $old_hash = $account->pass;
+    $account->pass = user_hash_password($password);
+    $this->assertTrue($account->pass != $old_hash, t('Password hash changed.'));
+    $this->assertTrue(user_check_password($password, $account), t('Password check succeeds.'));
+    // Since the log2 setting hasn't changed and the user has a valid password,
+    // user_needs_new_hash() should return FALSE.
+    $this->assertFalse(user_needs_new_hash($account), t('User does not need a new hash.'));
+    // Increment the log2 iteration to 16, which is deliberately out of bounds.
+    variable_set('password_count_log2', 16);
+    $this->assertTrue(user_needs_new_hash($account), t('User needs a new hash after incrementing the log2 count.'));
+    // Re-hash the password.
+    $old_hash = $account->pass;
+    $account->pass = user_hash_password($password);
+    $this->assertTrue($account->pass != $old_hash, t('Password hash changed again.'));
+    // Now the hash should be OK.
+    $this->assertFalse(user_needs_new_hash($account), t('Re-hashed password does not need a new hash.'));
+    $this->assertTrue(user_check_password($password, $account), t('Password check succeeds with re-hashed password.'));
+  }
+}
